# ``req-disposition`` -- disposition of client requests

This is the authoritative reference for the ``spec.req-disposition``
field of the [``VarnishConfig`` Custom
Resource](/docs/ref-varnish-cfg.md), which defines how client requests
are processed further after the request headers have been received.

The configuration in ``req-disposition`` causes the definition of [VCL
subroutine
``vcl_recv``](https://varnish-cache.org/docs/6.1/users-guide/vcl-built-in-subs.html#vcl-recv)
in
[``builtin.vcl``](https://github.com/varnishcache/varnish-cache/blob/6.1/bin/varnishd/builtin.vcl)
to be overridden. ``builtin.vcl`` acts as "default VCL"; after a
subroutine in the VCL generated by the controller has been executed,
if it does not use ``return`` to branch to another [processing
state](https://varnish-cache.org/docs/6.1/reference/states.html), then
the subroutine in ``builtin.vcl`` is executed. Built-in ``vcl_recv``
establishes default policies for client requests such as:

* which requests proceed to cache lookup, and hence may potentially be
  cache hits.

* which requests bypass cache lookup, and hence are never cache hits
  (and avoid the effects of [request
  coalescing](https://varnish-cache.org/docs/6.1/users-guide/increasing-your-hitrate.html#cache-misses)).

* how to handle requests with non-standard request methods.

A common use case for overriding built-in ``vcl_recv`` is to allow
caching for requests that use cookies or basic authentication. The
default policy in ``builtin.vcl`` takes a cautious approach by
bypassing cache lookup for such requests, since their responses may be
personalized. But especially since cookies are ubiquitous, it is often
necessary to override the default.

Note that if you override any part of built-in ``vcl_recv`` -- that is
if you configure ``req-disposition`` at all -- you must override all
of it. That is, you will have to consider policies for everything that
builtin-in ``vcl_recv`` implements in your configuration for
``req-disposition``, because no part of built-in ``vcl_recv`` will be
executed. You can, of course, make decisions that differ from those in
built-in ``vcl_recv``.

See the [``examples/`` folder](/examples/req-disposition) for working
examples of configurations for ``req-disposition``. Among these are:

* A reconstruction in YAML for everything that built-in ``vcl_recv``
  does, to illustrate how the same policies can be configured for
  Kubernetes.

* An alternative configuration for built-in ``vcl_recv``, to allow
  cache lookup for requests using cookies or basic authentication,
  and to make different decisions about some other policies.

* Bypassing cache lookup when the Cookie header contains a session
  token, but otherwise allowing cache lookup for requests with
  cookies.

* Bypassing cache lookup for certain URL path patterns, and explicitly
  invoking cache lookup for other URL patterns.

* URL white- and blacklisting -- immediately rejecting requests whose
  URL path does or does not match groups of patterns.

## Configuration

The configuration in ``req-disposition`` determines the next
[state](https://varnish-cache.org/docs/6.1/reference/states.html) in
the processing of a client request. The implementation of
``req-disposition`` is executed after everything else that runs in
``vcl_recv``, and bypasses built-in ``vcl_recv`` as discussed above.

``req-disposition`` is a non-empty array of objects with these two
fields, both of which are required:

* ``conditions``: a set of conditions against which a client request
  is matched

* ``disposition``: the next processing state for a client request
  that matches the ``conditions``

The ``conditions`` are evaluated for a client request in the order in
which they appear in the array. For the first object whose ``conditions``
match the client request, the request is processed further according to
the corresponding ``disposition``. If none of the ``conditions`` match,
then the request proceeds to cache lookup (``return(hash)``).

``disposition`` is an object with these two fields:

* ``action`` (required): one of the following strings, corresponnding
  to a [``return()`` keyword for
  ``vcl_recv``](https://varnish-cache.org/docs/6.1/users-guide/vcl-built-in-subs.html#vcl-recv);

    * ``hash``: cache lookup

    * ``pass``: bypass cache lookup

    * ``synth``: return a synthetic response

    * ``pipe``: Varnish acts as a
      [tunnel](https://varnish-cache.org/docs/6.1/users-guide/vcl-built-in-subs.html#vcl-pipe)
      between client and backend

    * ``restart``:
      [restart](https://varnish-cache.org/docs/6.1/users-guide/vcl-built-in-subs.html#restart)
      request processing

    * ``purge``: evict the cache object that corresponds to the
      request

    * ``fail``: invoke [VCL
      failure](https://varnish-cache.org/docs/6.1/users-guide/vcl-built-in-subs.html#fail)

* ``status``: the HTTP status of the synthetic response when
  ``action`` is ``synth``. Required for ``synth``, and ignored for
  other values of ``action``. ``status`` MUST be in the range 200 to
  599, inclusive.

It is not possible to use ``action`` to specify branching to a VCL label.

``conditions`` is an array of objects with the following fields,
describing all of the conditions that a client request that must
fulfill to invoke the corresponding ``disposition``:

* ``comparand`` (required): the "thing to be compared" -- one of the
  following
  (cf. [vcl(7)](https://varnish-cache.org/docs/6.1/reference/vcl.html#req-and-req-top)):

    * ``req.url``: URL path

    * ``req.http.$HEADER``. where ``$HEADER`` is a client request
      header.  For example, ``req.http.Cookie`` specifies the Cookie
      header.

    * ``req.method``: request method

    * ``req.proto``: HTTP protocol (such as "HTTP/1.1" or "HTTP/2")

    * ``req.esi_level``: the current depth of ESI
      includes. ``req.esi_level`` is 0 for requests that are not
      included.

    * ``req.restarts``: the number of times the request has been
      restarted.  ``req.restarts`` is 0 if the request has not been
      restarted.

* ``compare``: the operation by which the ``comparand`` is evaluated,
  possibly in relation to the strings in the ``values`` field, or the
  number in the ``count`` field, as documented further down. One of:

    * ``equal`` (default), ``not-equal``: test for equality or
      inequality with ``values`` or ``count``.

    * ``match``, ``not-match``: test if the ``comparand`` does or does
      not match any of the regular expressions in ``values``.

    * ``prefix``, ``not-prefix``: test if the ``comparand`` does or
      does not have a prefix that is specified in the ``values``
      array.

    * ``exists``, ``not-exists``: test if the header specified in the
      ``comparand`` as ``req.http.$HEADER`` is or is not present in
      the client request.

    * ``greater``, ``greater-equal``, ``less``, ``less-equal``: test
      the ``comparand`` against ``count`` with the numeric
      relation >, >=, < or <=, respectively.

    * When ``compare`` is ``exists`` or ``not-exists``, the
      ``comparand`` MUST be of the form ``req.http.$HEADER`` to
      specify a client request header. The ``values`` and ``count``
      fields are ignored.

    * When ``compare`` is any of ``match``, ``not-match``, ``prefix``
      or ``not-prefix``:

        * the ``values`` array MUST be specified.

        * the ``count`` field MAY NOT be specified.

        * ``comparand`` MUST be one of ``req.url``,
          ``req.http.$HEADER``, ``req.method`` or ``req.proto``. In
          other words, the ``comparand`` MUST designate a string
          value.
    
    * When ``compare`` is any of ``greater``, ``greater-equal``,
      ``less`` or ``less-equal``:

        * the ``count`` field MUST be specified.

        * the ``values`` array MAY NOT be specified.

        * ``comparand`` MUST be one of ``req.esi_level`` or
          ``req.restarts``.  That is, the ``comparand`` MUST designate
          a numeric value.
    
* ``values``: if present, a non-empty array of strings to which the
  ``comparand`` is compared, according to the relation specified by
  ``compare``. If ``values`` is specified, then:

    * ``count`` MAY NOT be specified.

    * ``compare`` MUST be one of ``equal``, ``not-equal``, ``match``,
      ``not-match``, ``prefix`` or ``not-prefix``.

    * ``comparand`` MUST be one of ``req.url``, ``req.http.$HEADER``,
      ``req.method`` or ``req.proto``.

    * When ``compare`` is ``match`` or ``not-match``, the strings in
      ``values`` have the syntax and semantics of [RE2 regular
      expressions](https://github.com/google/re2).

    * When ``compare`` is ``equal``, ``not-equal``, ``prefix`` or
      ``not-prefix`` the strings in ``values`` are fixed strings or
      prefixes. Characters such as regular expression metacharacters
      or wildcards have no special meaning.

* ``count``: if present, a number to which the ``comparand`` is
  compared according to ``compare``. If ``count`` is specfied:

    * ``values`` MAY NOT be specified.

    * ``compare`` MUST be one of ``equal``, ``not-equal``,
      ``greater``, ``greater-equal``, ``less`` or ``less-equal``.

    * ``comparand`` MUST be one of ``req.esi_level`` or
      ``req.restarts``.

* ``match-flags``: if present, an object with configuration to
  control string comparison operations. If ``match-flags`` is absent,
  then comparisons are executed with default options. See the
  [``match-flags`` specification](/docs/ref-match-flags.md) for
  details. ``match-flags`` is ignored for numeric comparisons
  (when ``count`` is specified).

When more than one string is specified in ``values``, the condition
evaluates as true if the ``compare`` relation with ``comparand`` holds
for any one of the strings. In other words, the array represents a
boolean OR of comparisons. For example, this condition evaluates as
true if the client request header ``Foo`` has either of the values
``bar`` or ``baz``:

```
  - comparand: req.http.Foo
    compare: equal
    values:
      - bar
      - baz
```

The complete set of ``conditions`` is evaluated as true, and hence the
corresponding ``disposition`` is invoked, if each condition in the
array evaluates as true. In other words, the ``conditions`` array
represents a boolean AND of conditions.

## Example

This configuration reconstructs one of the rules in built-in
``vcl_recv`` as a ``req-disposition`` configuration -- a client
request is rejected as an error if it does not have a ``Host`` header,
when HTTP/1.1 is in use (since the HTTP standard requires it):

```
spec:
  req-disposition:
    - conditions:
      - comparand: req.http.Host
        compare: not-exists
      - comparand: req.esi_level
        count: 0
      - comparand: req.proto
        compare: prefix
        values:
          - HTTP/1.1
        match-flags:
          case-insensitive: true
      disposition:
        action: synth
        status: 400
```

The conditions in the ``conditions`` array specify a client request for which
all of the following are true:

* The ``Host`` header is not present in the request (``not-exists``).

* The request is not ESI-included -- ``req.esi_level`` == 0. We do not
  require this check for ESI-included requests. Notice that the
  ``compare`` field was left out, so the default comparison ``equals``
  is assumed.

* The protocol is specified as HTTP/1.1. This is considered true if
  ``req.proto`` begins with `"HTTP/1.1"`` (``compare: prefix``), and
  the match with the string is case-insensitive.

If all of these conditions are true, then the ``disposition`` is
executed. In this case, a synthetic "400 Bad Request" response is
generated.

See the [``examples/`` folder](/examples/req-disposition) for more
examples of the use of ``req-disposition``.